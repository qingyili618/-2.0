import { withInstall, withNoopInstall } from '../../utils/with-install';
import { defineComponent, openBlock, createBlock, Transition, mergeProps, toHandlers, withCtx, renderSlot, inject, computed, reactive, ref, getCurrentInstance, watch, provide, onMounted, onBeforeUnmount, h, Fragment, withDirectives, vShow, isRef, resolveComponent, createElementBlock, normalizeClass, normalizeStyle, createElementVNode, createTextVNode, toDisplayString } from 'vue';
import { Resize } from '../../directives';
import Menubar from '../../utils/menu/menu-bar';
import { addClass, removeClass, hasClass } from '../../utils/dom';
import ElCollapseTransition from '../collapse-transition';
import ElPopper, { Effect } from '../popper';
import ElTooltip from '../tooltip';

var script$3 = defineComponent({
  name: "ElMenuCollapseTransition",
  setup() {
    return {
      on: {
        beforeEnter(el) {
          el.style.opacity = "0.2";
        },
        enter(el, done) {
          addClass(el, "el-opacity-transition");
          el.style.opacity = "1";
          done();
        },
        afterEnter(el) {
          removeClass(el, "el-opacity-transition");
          el.style.opacity = "";
        },
        beforeLeave(el) {
          if (!el.dataset) {
            el.dataset = {};
          }
          if (hasClass(el, "el-menu--collapse")) {
            removeClass(el, "el-menu--collapse");
            el.dataset.oldOverflow = el.style.overflow;
            el.dataset.scrollWidth = el.clientWidth.toString();
            addClass(el, "el-menu--collapse");
          } else {
            addClass(el, "el-menu--collapse");
            el.dataset.oldOverflow = el.style.overflow;
            el.dataset.scrollWidth = el.clientWidth.toString();
            removeClass(el, "el-menu--collapse");
          }
          el.style.width = `${el.scrollWidth}px`;
          el.style.overflow = "hidden";
        },
        leave(el) {
          addClass(el, "horizontal-collapse-transition");
          el.style.width = `${el.dataset.scrollWidth}px`;
        }
      }
    };
  }
});

function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, mergeProps({ mode: "out-in" }, toHandlers(_ctx.on)), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16);
}

script$3.render = render$2;
script$3.__file = "packages/components/menu/src/menu-collapse-transition.vue";

function useMenu(instance, currentIndex) {
  const rootMenu = inject("rootMenu");
  const indexPath = computed(() => {
    let parent = instance.parent;
    const path = [currentIndex.value];
    while (parent.type.name !== "ElMenu") {
      if (parent.props.index) {
        path.unshift(parent.props.index);
      }
      parent = parent.parent;
    }
    return path;
  });
  const parentMenu = computed(() => {
    let parent = instance.parent;
    while (parent && ["ElMenu", "ElSubMenu"].indexOf(parent.type.name) === -1) {
      parent = parent.parent;
    }
    return parent;
  });
  const paddingStyle = computed(() => {
    let parent = instance.parent;
    if (rootMenu.props.mode !== "vertical")
      return {};
    let padding = 20;
    if (rootMenu.props.collapse) {
      padding = 20;
    } else {
      while (parent && parent.type.name !== "ElMenu") {
        if (parent.type.name === "ElSubMenu") {
          padding += 20;
        }
        parent = parent.parent;
      }
    }
    return { paddingLeft: `${padding}px` };
  });
  return { parentMenu, paddingStyle, indexPath };
}

function useMenuColor(props) {
  const menuBarColor = computed(() => {
    const color = props.backgroundColor;
    if (!color) {
      return "";
    } else {
      return mixColor(color);
    }
  });
  function calcColorChannels(c) {
    let rawColor = c.replace("#", "");
    if (/^[0-9a-fA-F]{3}$/.test(rawColor)) {
      const color = rawColor.split("");
      for (let i = 2; i >= 0; i--) {
        color.splice(i, 0, color[i]);
      }
      rawColor = color.join("");
    }
    if (/^[0-9a-fA-F]{6}$/.test(rawColor)) {
      return {
        red: parseInt(rawColor.slice(0, 2), 16),
        green: parseInt(rawColor.slice(2, 4), 16),
        blue: parseInt(rawColor.slice(4, 6), 16)
      };
    } else {
      return {
        red: 255,
        green: 255,
        blue: 255
      };
    }
  }
  function mixColor(color, percent = 0.2) {
    let { red, green, blue } = calcColorChannels(color);
    if (percent > 0) {
      red *= 1 - percent;
      green *= 1 - percent;
      blue *= 1 - percent;
    } else {
      red += (255 - red) * percent;
      green += (255 - green) * percent;
      blue += (255 - blue) * percent;
    }
    return `rgb(${Math.round(red)}, ${Math.round(green)}, ${Math.round(blue)})`;
  }
  return menuBarColor;
}

const useMenuCssVar = (props) => {
  return computed(() => {
    return {
      "--el-menu-text-color": props.textColor || "",
      "--el-menu-hover-text-color": props.textColor || "",
      "--el-menu-background-color": props.backgroundColor || "",
      "--el-menu-hover-background-color": useMenuColor(props).value || "",
      "--el-menu-active-color": props.activeTextColor || ""
    };
  });
};

var script$2 = defineComponent({
  name: "ElSubMenu",
  props: {
    index: {
      type: String,
      required: true
    },
    showTimeout: {
      type: Number,
      default: 300
    },
    hideTimeout: {
      type: Number,
      default: 300
    },
    popperClass: String,
    disabled: Boolean,
    popperAppendToBody: {
      type: Boolean,
      default: void 0
    }
  },
  setup(props) {
    const data = reactive({
      popperJS: null,
      timeout: null,
      items: {},
      submenus: {},
      currentPlacement: "",
      mouseInChild: false,
      opened: false
    });
    const verticalTitleRef = ref(null);
    const popperVnode = ref(null);
    const instance = getCurrentInstance();
    const { paddingStyle, indexPath, parentMenu } = useMenu(instance, computed(() => props.index));
    const {
      openedMenus,
      isMenuPopup,
      methods: rootMethods,
      props: rootProps,
      methods: { closeMenu }
    } = inject("rootMenu");
    const {
      addSubMenu: parentAddSubMenu,
      removeSubMenu: parentRemoveSubMenu,
      handleMouseleave: parentHandleMouseleave
    } = inject(`subMenu:${parentMenu.value.uid}`);
    const submenuTitleIcon = computed(() => {
      return mode.value === "horizontal" && isFirstLevel.value || mode.value === "vertical" && !rootProps.collapse ? "el-icon-arrow-down" : "el-icon-arrow-right";
    });
    const isFirstLevel = computed(() => {
      let isFirstLevel2 = true;
      let parent = instance.parent;
      while (parent && parent.type.name !== "ElMenu") {
        if (["ElSubMenu", "ElMenuItemGroup"].includes(parent.type.name)) {
          isFirstLevel2 = false;
          break;
        } else {
          parent = parent.parent;
        }
      }
      return isFirstLevel2;
    });
    const appendToBody = computed(() => {
      return props.popperAppendToBody === void 0 ? isFirstLevel.value : Boolean(props.popperAppendToBody);
    });
    const menuTransitionName = computed(() => {
      return rootProps.collapse ? "el-zoom-in-left" : "el-zoom-in-top";
    });
    const fallbackPlacements = computed(() => mode.value === "horizontal" && isFirstLevel.value ? [
      "bottom-start",
      "bottom-end",
      "top-start",
      "top-end",
      "right-start",
      "left-start"
    ] : [
      "right-start",
      "left-start",
      "bottom-start",
      "bottom-end",
      "top-start",
      "top-end"
    ]);
    const opened = computed(() => {
      return openedMenus.value.includes(props.index);
    });
    const active = computed(() => {
      let isActive = false;
      const submenus = data.submenus;
      const items = data.items;
      Object.keys(items).forEach((index) => {
        if (items[index].active) {
          isActive = true;
        }
      });
      Object.keys(submenus).forEach((index) => {
        if (submenus[index].active) {
          isActive = true;
        }
      });
      return isActive;
    });
    const backgroundColor = computed(() => {
      return rootProps.backgroundColor || "";
    });
    const activeTextColor = computed(() => {
      return rootProps.activeTextColor || "";
    });
    const textColor = computed(() => {
      return rootProps.textColor || "";
    });
    const mode = computed(() => {
      return rootProps.mode;
    });
    const titleStyle = computed(() => {
      if (mode.value !== "horizontal") {
        return {
          color: textColor.value
        };
      }
      return {
        borderBottomColor: active.value ? rootProps.activeTextColor ? activeTextColor.value : "" : "transparent",
        color: active.value ? activeTextColor.value : textColor.value
      };
    });
    const doDestroy = () => {
      var _a;
      (_a = popperVnode.value) == null ? void 0 : _a.doDestroy();
    };
    const handleCollapseToggle = (value) => {
      if (value) {
        updatePlacement();
      } else {
        doDestroy();
      }
    };
    const addItem = (item) => {
      data.items[item.index] = item;
    };
    const removeItem = (item) => {
      delete data.items[item.index];
    };
    const addSubMenu = (item) => {
      data.submenus[item.index] = item;
    };
    const removeSubMenu = (item) => {
      delete data.submenus[item.index];
    };
    const handleClick = () => {
      const disabled = props.disabled;
      if (rootProps.menuTrigger === "hover" && rootProps.mode === "horizontal" || rootProps.collapse && rootProps.mode === "vertical" || disabled) {
        return;
      }
      rootMethods.handleSubMenuClick({ index: props.index, indexPath });
    };
    const handleMouseenter = (event, showTimeout = props.showTimeout) => {
      if (!("ActiveXObject" in window) && event.type === "focus" && !event.relatedTarget) {
        return;
      }
      const disabled = props.disabled;
      if (rootProps.menuTrigger === "click" && rootProps.mode === "horizontal" || !rootProps.collapse && rootProps.mode === "vertical" || disabled) {
        return;
      }
      data.mouseInChild = true;
      clearTimeout(data.timeout);
      data.timeout = setTimeout(() => {
        rootMethods.openMenu(props.index, indexPath);
      }, showTimeout);
      if (appendToBody.value) {
        parentMenu.value.vnode.el.dispatchEvent(new MouseEvent("mouseenter"));
      }
    };
    const handleMouseleave = (deepDispatch = false) => {
      if (rootProps.menuTrigger === "click" && rootProps.mode === "horizontal" || !rootProps.collapse && rootProps.mode === "vertical") {
        return;
      }
      data.mouseInChild = false;
      clearTimeout(data.timeout);
      data.timeout = setTimeout(() => {
        !data.mouseInChild && closeMenu(props.index);
      }, props.hideTimeout);
      if (appendToBody.value && deepDispatch) {
        if (instance.parent.type.name === "ElSubMenu") {
          parentHandleMouseleave(true);
        }
      }
    };
    const updatePlacement = () => {
      data.currentPlacement = mode.value === "horizontal" && isFirstLevel.value ? "bottom-start" : "right-start";
    };
    watch(() => rootProps.collapse, (value) => {
      handleCollapseToggle(Boolean(value));
    });
    provide(`subMenu:${instance.uid}`, {
      addSubMenu,
      removeSubMenu,
      handleMouseleave
    });
    onMounted(() => {
      rootMethods.addSubMenu({
        index: props.index,
        indexPath,
        active
      });
      parentAddSubMenu({
        index: props.index,
        indexPath,
        active
      });
      updatePlacement();
    });
    onBeforeUnmount(() => {
      parentRemoveSubMenu({
        index: props.index,
        indexPath,
        active
      });
      rootMethods.removeSubMenu({
        index: props.index,
        indexPath,
        active
      });
    });
    return {
      data,
      props,
      mode,
      active,
      isMenuPopup,
      opened,
      paddingStyle,
      titleStyle,
      backgroundColor,
      rootProps,
      menuTransitionName,
      fallbackPlacements,
      submenuTitleIcon,
      appendToBody,
      handleClick,
      handleMouseenter,
      handleMouseleave,
      addItem,
      removeItem,
      addSubMenu,
      removeSubMenu,
      popperVnode,
      verticalTitleRef
    };
  },
  render() {
    var _a, _b;
    const titleTag = [
      (_b = (_a = this.$slots).title) == null ? void 0 : _b.call(_a),
      h("i", {
        class: ["el-sub-menu__icon-arrow", this.submenuTitleIcon]
      }, null)
    ];
    const ulStyle = useMenuCssVar(this.rootProps);
    const child = this.isMenuPopup ? h(ElPopper, {
      ref: "popperVNode",
      manualMode: true,
      visible: this.opened,
      "onUpdate:visible": (val) => this.opened = val,
      effect: "light",
      pure: true,
      offset: 6,
      showArrow: false,
      popperClass: this.popperClass,
      placement: this.data.currentPlacement,
      appendToBody: this.appendToBody,
      fallbackPlacements: this.fallbackPlacements,
      transition: this.menuTransitionName,
      gpuAcceleration: false
    }, {
      default: () => {
        var _a2, _b2;
        return h("div", {
          ref: "menu",
          class: [`el-menu--${this.mode}`, this.popperClass],
          onMouseenter: ($event) => this.handleMouseenter($event, 100),
          onMouseleave: () => this.handleMouseleave(true),
          onFocus: ($event) => this.handleMouseenter($event, 100)
        }, [
          h("ul", {
            class: [
              "el-menu el-menu--popup",
              `el-menu--popup-${this.data.currentPlacement}`
            ],
            style: ulStyle
          }, [(_b2 = (_a2 = this.$slots).default) == null ? void 0 : _b2.call(_a2)])
        ]);
      },
      trigger: () => h("div", {
        class: "el-sub-menu__title",
        style: [
          this.paddingStyle,
          this.titleStyle,
          { backgroundColor: this.backgroundColor }
        ],
        onClick: this.handleClick
      }, titleTag)
    }) : h(Fragment, {}, [
      h("div", {
        class: "el-sub-menu__title",
        style: [
          this.paddingStyle,
          this.titleStyle,
          { backgroundColor: this.backgroundColor }
        ],
        ref: "verticalTitleRef",
        onClick: this.handleClick
      }, titleTag),
      h(ElCollapseTransition, {}, {
        default: () => {
          var _a2, _b2;
          return withDirectives(h("ul", {
            role: "menu",
            class: "el-menu el-menu--inline",
            style: ulStyle.value
          }, [(_b2 = (_a2 = this.$slots).default) == null ? void 0 : _b2.call(_a2)]), [[vShow, this.opened]]);
        }
      })
    ]);
    return h("li", {
      class: [
        "el-sub-menu",
        {
          "is-active": this.active,
          "is-opened": this.opened,
          "is-disabled": this.disabled
        }
      ],
      role: "menuitem",
      ariaHaspopup: true,
      ariaExpanded: this.opened,
      onMouseenter: this.handleMouseenter,
      onMouseleave: () => this.handleMouseleave(true),
      onFocus: this.handleMouseenter
    }, [child]);
  }
});

script$2.__file = "packages/components/menu/src/submenu.vue";

var Menu = defineComponent({
  name: "ElMenu",
  props: {
    mode: {
      type: String,
      default: "vertical"
    },
    defaultActive: {
      type: String,
      default: ""
    },
    defaultOpeneds: Array,
    uniqueOpened: Boolean,
    router: Boolean,
    menuTrigger: {
      type: String,
      default: "hover"
    },
    collapse: Boolean,
    backgroundColor: { type: String },
    textColor: { type: String },
    activeTextColor: { type: String },
    collapseTransition: {
      type: Boolean,
      default: true
    }
  },
  emits: ["close", "open", "select"],
  setup(props, { emit, slots, expose }) {
    const openedMenus = ref(props.defaultOpeneds && !props.collapse ? props.defaultOpeneds.slice(0) : []);
    const instance = getCurrentInstance();
    const activeIndex = ref(props.defaultActive);
    const items = ref({});
    const submenus = ref({});
    const alteredCollapse = ref(false);
    const router = instance.appContext.config.globalProperties.$router;
    const menu = ref(null);
    const isMenuPopup = computed(() => {
      return props.mode === "horizontal" || props.mode === "vertical" && props.collapse;
    });
    const initializeMenu = () => {
      const index = activeIndex.value;
      const activeItem = items.value[index];
      if (!activeItem || props.mode === "horizontal" || props.collapse)
        return;
      const indexPath = activeItem.indexPath;
      indexPath.forEach((index2) => {
        const submenu = submenus.value[index2];
        submenu && openMenu(index2, submenu == null ? void 0 : submenu.indexPath);
      });
    };
    const addSubMenu = (item) => {
      submenus.value[item.index] = item;
    };
    const removeSubMenu = (item) => {
      delete submenus.value[item.index];
    };
    const addMenuItem = (item) => {
      items.value[item.index] = item;
    };
    const removeMenuItem = (item) => {
      delete items.value[item.index];
    };
    const openMenu = (index, indexPath) => {
      if (openedMenus.value.includes(index))
        return;
      if (props.uniqueOpened) {
        openedMenus.value = openedMenus.value.filter((index2) => {
          return (isRef(indexPath) ? indexPath.value : indexPath).indexOf(index2) !== -1;
        });
      }
      openedMenus.value.push(index);
    };
    const closeMenu = (index) => {
      const i = openedMenus.value.indexOf(index);
      if (i !== -1) {
        openedMenus.value.splice(i, 1);
      }
    };
    const open = (index) => {
      const { indexPath } = submenus.value[index.toString()];
      indexPath.forEach((i) => openMenu(i, indexPath));
    };
    const close = (index) => {
      closeMenu(index);
    };
    const handleSubMenuClick = (submenu) => {
      const { index, indexPath } = submenu;
      const isOpened = openedMenus.value.includes(index);
      if (isOpened) {
        closeMenu(index);
        emit("close", index, indexPath.value);
      } else {
        openMenu(index, indexPath);
        emit("open", index, indexPath.value);
      }
    };
    const handleMenuItemClick = (item) => {
      const { index, indexPath } = item;
      const hasIndex = item.index !== null;
      const emitParams = [index, indexPath.value, item];
      if (props.mode === "horizontal" || props.collapse) {
        openedMenus.value = [];
      }
      if (!hasIndex) {
        return;
      }
      if (props.router && router) {
        const route = item.route || item.index;
        const routerResult = router.push(route).then((navigationResult) => {
          if (!navigationResult) {
            activeIndex.value = item.index;
          }
          return navigationResult;
        });
        emit("select", ...emitParams.concat(routerResult));
      } else {
        activeIndex.value = item.index;
        emit("select", ...emitParams);
      }
    };
    const updateActiveIndex = (val) => {
      const itemsInData = items.value;
      const item = itemsInData[val] || itemsInData[activeIndex.value] || itemsInData[props.defaultActive];
      if (item) {
        activeIndex.value = item.index;
        initializeMenu();
      } else {
        if (!alteredCollapse.value) {
          activeIndex.value = null;
        } else {
          alteredCollapse.value = false;
        }
      }
    };
    const handleResize = () => instance.proxy.$forceUpdate();
    watch(() => props.defaultActive, (currentActive) => {
      if (!items.value[currentActive]) {
        activeIndex.value = "";
      }
      updateActiveIndex(currentActive);
    });
    watch(items.value, () => {
      initializeMenu();
    });
    watch(() => props.collapse, (value, prev) => {
      if (value !== prev) {
        alteredCollapse.value = true;
      }
      if (value)
        openedMenus.value = [];
    });
    provide("rootMenu", {
      props,
      openedMenus,
      items,
      submenus,
      activeIndex,
      isMenuPopup,
      methods: {
        addMenuItem,
        removeMenuItem,
        addSubMenu,
        removeSubMenu,
        openMenu,
        closeMenu,
        handleMenuItemClick,
        handleSubMenuClick
      }
    });
    provide(`subMenu:${instance.uid}`, {
      addSubMenu,
      removeSubMenu
    });
    onMounted(() => {
      initializeMenu();
      if (props.mode === "horizontal") {
        new Menubar(instance.vnode.el);
      }
    });
    expose({
      open,
      close
    });
    const flattedChildren = (children) => {
      const temp = Array.isArray(children) ? children : [children];
      const res = [];
      temp.forEach((child) => {
        if (Array.isArray(child.children)) {
          res.push(...flattedChildren(child.children));
        } else {
          res.push(child);
        }
      });
      return res;
    };
    const useVNodeResize = (vnode) => props.mode === "horizontal" ? withDirectives(vnode, [[Resize, handleResize]]) : vnode;
    return () => {
      var _a, _b, _c, _d;
      let slot = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : [];
      const showMore = [];
      if (props.mode === "horizontal" && menu.value) {
        const items2 = Array.from((_d = (_c = menu.value) == null ? void 0 : _c.childNodes) != null ? _d : []).filter((item) => item.nodeName !== "#text" || item.nodeValue);
        const originalSlot = flattedChildren(slot);
        const moreItemWidth = 64;
        const paddingLeft = parseInt(getComputedStyle(menu.value).paddingLeft, 10);
        const paddingRight = parseInt(getComputedStyle(menu.value).paddingRight, 10);
        const menuWidth = menu.value.clientWidth - paddingLeft - paddingRight;
        let calcWidth = 0;
        let sliceIndex = 0;
        items2.forEach((item, index) => {
          calcWidth += item.offsetWidth || 0;
          if (calcWidth <= menuWidth - moreItemWidth) {
            sliceIndex = index + 1;
          }
        });
        const defaultSlot = originalSlot.slice(0, sliceIndex);
        const moreSlot = originalSlot.slice(sliceIndex);
        if (moreSlot == null ? void 0 : moreSlot.length) {
          slot = defaultSlot;
          showMore.push(h(script$2, {
            index: "sub-menu-more",
            class: "el-sub-menu__hide-arrow"
          }, {
            title: () => h("i", {
              class: ["el-icon-more", "el-sub-menu__icon-more"]
            }),
            default: () => moreSlot
          }));
        }
      }
      const ulStyle = useMenuCssVar(props);
      const vnodeMenu = useVNodeResize(h("ul", {
        key: String(props.collapse),
        role: "menubar",
        ref: menu,
        style: ulStyle.value,
        class: {
          "el-menu": true,
          "el-menu--horizontal": props.mode === "horizontal",
          "el-menu--collapse": props.collapse
        }
      }, [...slot.map((vnode) => useVNodeResize(vnode)), ...showMore]));
      if (props.collapseTransition && props.mode === "vertical") {
        return h(script$3, () => vnodeMenu);
      }
      return vnodeMenu;
    };
  }
});

var script$1 = defineComponent({
  name: "ElMenuItem",
  components: { ElTooltip },
  props: {
    index: {
      type: String,
      default: null
    },
    route: [String, Object],
    disabled: Boolean
  },
  emits: ["click"],
  setup(props, { emit, slots }) {
    const instance = getCurrentInstance();
    const rootMenu = inject("rootMenu");
    const { parentMenu, paddingStyle, indexPath } = useMenu(instance, computed(() => props.index));
    const { addSubMenu, removeSubMenu } = inject(`subMenu:${parentMenu.value.uid}`);
    const active = computed(() => {
      return props.index === rootMenu.activeIndex.value;
    });
    const handleClick = () => {
      if (!props.disabled) {
        rootMenu.methods.handleMenuItemClick({
          index: props.index,
          indexPath,
          route: props.route
        });
        emit("click", {
          index: props.index,
          indexPath: indexPath.value
        });
      }
    };
    onMounted(() => {
      addSubMenu({ index: props.index, indexPath, active });
      rootMenu.methods.addMenuItem({ index: props.index, indexPath, active });
    });
    onBeforeUnmount(() => {
      removeSubMenu({ index: props.index, indexPath, active });
      rootMenu.methods.removeMenuItem({ index: props.index, indexPath, active });
    });
    return {
      Effect,
      parentMenu,
      rootMenu,
      slots,
      paddingStyle,
      active,
      handleClick
    };
  }
});

const _hoisted_1$1 = { style: { "position": "absolute", "left": "0", "top": "0", "height": "100%", "width": "100%", "display": "inline-block", "box-sizing": "border-box", "padding": "0 20px" } };
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip = resolveComponent("el-tooltip");
  return openBlock(), createElementBlock("li", {
    class: normalizeClass(["el-menu-item", {
      "is-active": _ctx.active,
      "is-disabled": _ctx.disabled
    }]),
    role: "menuitem",
    tabindex: "-1",
    style: normalizeStyle(_ctx.paddingStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.parentMenu.type.name === "ElMenu" && _ctx.rootMenu.props.collapse && _ctx.slots.title ? (openBlock(), createBlock(_component_el_tooltip, {
      key: 0,
      effect: _ctx.Effect.DARK,
      placement: "right"
    }, {
      content: withCtx(() => [
        renderSlot(_ctx.$slots, "title")
      ]),
      default: withCtx(() => [
        createElementVNode("div", _hoisted_1$1, [
          renderSlot(_ctx.$slots, "default")
        ])
      ]),
      _: 3
    }, 8, ["effect"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      renderSlot(_ctx.$slots, "default"),
      renderSlot(_ctx.$slots, "title")
    ], 64))
  ], 6);
}

script$1.render = render$1;
script$1.__file = "packages/components/menu/src/menuItem.vue";

var script = defineComponent({
  name: "ElMenuItemGroup",
  componentName: "ElMenuItemGroup",
  props: {
    title: {
      type: String
    }
  },
  setup(props, { slots }) {
    const data = reactive({
      paddingLeft: 20
    });
    const instance = getCurrentInstance();
    const levelPadding = computed(() => {
      let padding = 20;
      let parent = instance.parent;
      if (rootProps.collapse)
        return 20;
      while (parent && parent.type.name !== "ElMenu") {
        if (parent.type.name === "ElSubMenu") {
          padding += 20;
        }
        parent = parent.parent;
      }
      return padding;
    });
    const { props: rootProps } = inject("rootMenu");
    return {
      data,
      levelPadding,
      props,
      slots
    };
  }
});

const _hoisted_1 = { class: "el-menu-item-group" };
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", _hoisted_1, [
    createElementVNode("div", {
      class: "el-menu-item-group__title",
      style: normalizeStyle({ paddingLeft: _ctx.levelPadding + "px" })
    }, [
      !_ctx.slots.title ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createTextVNode(toDisplayString(_ctx.title), 1)
      ], 2112)) : renderSlot(_ctx.$slots, "title", { key: 1 })
    ], 4),
    createElementVNode("ul", null, [
      renderSlot(_ctx.$slots, "default")
    ])
  ]);
}

script.render = render;
script.__file = "packages/components/menu/src/menuItemGroup.vue";

const ElMenu = withInstall(Menu, {
  MenuItem: script$1,
  MenuItemGroup: script,
  SubMenu: script$2
});
const ElMenuItem = withNoopInstall(script$1);
const ElMenuItemGroup = withNoopInstall(script);
const ElSubMenu = withNoopInstall(script$2);

export { ElMenu, ElMenuItem, ElMenuItemGroup, ElSubMenu, ElMenu as default };
